# 创建对象

## 1.工厂模式

>可以创建多个对象, 但是没有解决识别多个对象的问题(判断对象的类型)

    function createPerson(name, age, job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function(){
            console.log(this.name);
        }

        return o;
    }
    var person = createPerson('ljh',21, 'front engineer');

## 2.构造函数模式

>使用了`new`操作符, 没有return语句; 但是每个对象的完成同样任务的方法都创建了一次.

    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            console.log(this.name);
        }
    }

## 3.原型模式

>使用每个函数都有的`prototype`属性, 可以让所有实例对象共享它所包含的属性和方法
>>但是很少单独使用原型模式, 因为实例一般要拥有自己的属性, 而不应该共享

    function Person(){}

    Person.prototype.name = 'ljh';
    Person.prototype.age = 21;
    Person.prototype.job = 'front engineer';
    Person.prototype.sayName = function(){
        console.log(this.name);
    }

    var person1 = new Person();
    var person2 = new Person();

    person1.name; //ljh
    person1.sayName() === person2.sayName(); //true

## 4.组合使用构造函数模式和原型模式 

>构造函数模式用来定义实例的属性, 而原型模式用于定义方法和共享的属性

    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
    }
    Person.prototype.sayName = function(){
        console.log(this.name);
    }

## 5.动态原型模式

>通过检查某个应该存在的方法是否有效, 来决定是否需要初始化原型
> 除了创建原型方法外, 注意new操作符

    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;

        if(typeof this.sayName !== 'function'){
            Person.prototype.sayName = function(){
                console.log(this.name);
            }
        }
    }

    var person = new Person('ljh',21,'front engineer');

## 6.寄生构造函数模式

>除了使用new操作符外, 跟工厂模式一模一样

    function Person(name, age, job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function(){
            console.log(this.name);
        }
        return o;
    }

    var person = new Person('ljh',21,'front engineer');

>假设想创建一个具有额外方法的特殊数组, 由于不能直接修改Array的构造函数, 就可以使用模式
>>缺点: 不能依赖instanceof操作符来确定对象类型

    function SpecialArray(){
        var values = new Array();

        values.push.apply(values, arguments);

        values.toPipedString = function(){
            return this.join('|');
        }

        return values;
    }

    var color = new SpecialArray('red','green','blue');
    console.log(color.toPipedString);