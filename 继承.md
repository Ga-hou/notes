# JS中的继承

## 1.原型链继承
>实现的本质是重写原型对象

    function SuperType(){
        this.prototype = true;
    }
    SuperType.prototype.getSuperValue = function(){
        return this.prototype;
    }

    function SubType(){
        this.subprototype = false;
    }
    SubType.prototype = new SuperType();

    SubType.prototype.getSubValue = function(){
        return this.prototype;
    }

## 2.借用构造函数
>在子类构造函数的内部调用父类构造函数
>>缺点是方法都在构造函数定义, 不能实现函数复用

    function SuperType(){
        this.prototype = true;
    }
    SuperType.prototype.getSuperValue = function(){
        return this.prototype;
    }

    function SubType(){
        //继承了SuperType
        SuperType.call(this);
    }

    var instance = new SubType();


## 3.组合继承
>使用`原型链`实现对原型属性和方法的继承
>通过借用`构造函数`来实现对实例属性的继承

    function SuperType(name){
        this.name = name;
        this.color = ['red','green','blue'];
    }
    SuperType.prototype.sayName = function(){
        console.log(this.name);
    }

    function SubType(name, age){
        //继承属性
        SuperType.call(this,name);

        this.age = age;
    }
    //继承方法
    SubType.prototype = new SubType();
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function(){
        console.log(this.age);
    }


## 4.原型式继承
>借助原型可以基于已有的对象创建新对象
>但是Object.create()是浅复制, 所以会共享相应的值

    function create(o){
        function F(){}
        F.prototype = o;
        return new F();
    }

>ES5通过新增Object.create()规范化了原型式继承

    var person = {
        name: 'ljh',
        firends: ['he','hei',ha']
    }

    var anotherPerson = Object.create(person);

## 5.寄生式继承
>创建一个仅用于封装继承过程的函数, 在内部已某种方式来增强对象
>>缺点是不能做到函数复用

    function createAnother(original){
        var clone = Object.create(original);
        clone.sayHi = function(){
            console.log('hi');
        }

        return clone;
    }

    var person = {
        name: 'ljh',
        age: 21
    }

    var anotherPerson = createAnother(person);
    anotherPerson.sayHi(); //hi

## 6.寄生组合继承
>最理想的继承范式
>只调用一次父类的构造函数

    function inheritPrototype(subType, superType){
        var prototype = Object.create(superType.prototupe);
        prototype.constructor = prototype;
        subType.prototype = prototype;
    }

    function SuperType(name){
        this.name = name;
        this.colors = ['red','green','blue'];
    }
    SuperType.prototype.sayName = function(){
        console.log(this.name);
    }
    function SubType(name,age){
        SuperType.call(this,name);
        this.age = age;
    }

    inheritPrototype(SubType,SuperType);

    SubType.prototype.sayAge = function(){
        console.log(this.age);
    }

## 7.ES6中的继承
    